{
  "_args": [
    [
      {
        "raw": "memoizee@0.4.X",
        "scope": null,
        "escapedName": "memoizee",
        "name": "memoizee",
        "rawSpec": "0.4.X",
        "spec": ">=0.4.0 <0.5.0",
        "type": "range"
      },
      "/home/konstantin/development/cifro/node_modules/debug-fabulous"
    ]
  ],
  "_from": "memoizee@>=0.4.0 <0.5.0",
  "_id": "memoizee@0.4.11",
  "_inCache": true,
  "_location": "/memoizee",
  "_nodeVersion": "8.4.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/memoizee-0.4.11.tgz_1505127956061_0.559158350341022"
  },
  "_npmUser": {
    "name": "medikoo",
    "email": "medikoo+npm@medikoo.com"
  },
  "_npmVersion": "4.6.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "memoizee@0.4.X",
    "scope": null,
    "escapedName": "memoizee",
    "name": "memoizee",
    "rawSpec": "0.4.X",
    "spec": ">=0.4.0 <0.5.0",
    "type": "range"
  },
  "_requiredBy": [
    "/debug-fabulous"
  ],
  "_resolved": "https://registry.npmjs.org/memoizee/-/memoizee-0.4.11.tgz",
  "_shasum": "bde9817663c9e40fdb2a4ea1c367296087ae8c8f",
  "_shrinkwrap": null,
  "_spec": "memoizee@0.4.X",
  "_where": "/home/konstantin/development/cifro/node_modules/debug-fabulous",
  "author": {
    "name": "Mariusz Nowak",
    "email": "medikoo@medikoo.com",
    "url": "http://www.medikoo.com/"
  },
  "bugs": {
    "url": "https://github.com/medikoo/memoizee/issues"
  },
  "dependencies": {
    "d": "1",
    "es5-ext": "^0.10.30",
    "es6-weak-map": "^2.0.2",
    "event-emitter": "^0.3.5",
    "is-promise": "^2.1",
    "lru-queue": "0.1",
    "next-tick": "1",
    "timers-ext": "^0.1.2"
  },
  "description": "Memoize/cache function results",
  "devDependencies": {
    "eslint": "^4.6.1",
    "eslint-config-medikoo-es5": "^1.4.3",
    "plain-promise": "^0.1.1",
    "tad": "^0.2.7"
  },
  "directories": {},
  "dist": {
    "shasum": "bde9817663c9e40fdb2a4ea1c367296087ae8c8f",
    "tarball": "https://registry.npmjs.org/memoizee/-/memoizee-0.4.11.tgz"
  },
  "eslintConfig": {
    "extends": "medikoo-es5",
    "root": true,
    "globals": {
      "setTimeout": true,
      "clearTimeout": true
    }
  },
  "gitHead": "c0c1de85e445aed6876fa931dd763e8a800375e8",
  "homepage": "https://github.com/medikoo/memoizee#readme",
  "keywords": [
    "memoize",
    "memoizer",
    "cache",
    "memoization",
    "memo",
    "memcached",
    "hashing.",
    "storage",
    "caching",
    "memory",
    "gc",
    "weak",
    "garbage",
    "collector",
    "async"
  ],
  "license": "MIT",
  "maintainers": [
    {
      "name": "medikoo",
      "email": "medikoo+npm@medikoo.com"
    }
  ],
  "name": "memoizee",
  "optionalDependencies": {},
  "readme": "# Memoizee\n## Complete memoize/cache solution for JavaScript\n\n_Originally derived from [es5-ext](https://github.com/medikoo/es5-ext) package._\n\nMemoization is best technique to save on memory or CPU cycles when we deal with repeated operations. For detailed insight see: http://en.wikipedia.org/wiki/Memoization\n\n### Features\n\n* Works with any type of function arguments – __no serialization is needed__\n* Works with [__any length of function arguments__](#arguments-length). Length can be set as fixed or dynamic.\n* One of the [__fastest__](#benchmarks) available solutions.\n* Support for [__promises__](#promise-returning-functions) and [__asynchronous functions__](#nodejs-callback-style-functions)\n* [__Primitive mode__](#primitive-mode) which assures fast performance when arguments are convertible to strings.\n* [__WeakMap based mode__](#weakmap-based-configurations) for garbage collection friendly configuration\n* Can be configured [__for methods__](#memoizing-methods) (when `this` counts in)\n* Cache [__can be cleared manually__](#manual-clean-up) or [__after specified timeout__](#expire-cache-after-given-period-of-time)\n* Cache size can be __[limited on LRU basis](#limiting-cache-size)__\n* Optionally [__accepts resolvers__](#resolvers) that normalize function arguments before passing them to underlying function.\n* Optional [__reference counter mode__](#reference-counter), that allows more sophisticated cache management\n* [__Profile tool__](#profiling--statistics) that provides valuable usage statistics\n* Covered by [__over 500 unit tests__](#tests-)\n\n### Installation\n\nIn your project path — __note the two `e`'s in `memoizee`:__\n\n\t$ npm install memoizee\n\n_`memoize` name was already taken, therefore project is published as `memoizee` on NPM._\n\nTo port it to Browser or any other (non CJS) environment, use your favorite CJS bundler. No favorite yet? Try: [Browserify](http://browserify.org/), [Webmake](https://github.com/medikoo/modules-webmake) or [Webpack](http://webpack.github.io/)\n\n### Usage\n\n```javascript\nvar memoize = require('memoizee');\n\nvar fn = function (one, two, three) { /* ... */ };\n\nmemoized = memoize(fn);\n\nmemoized('foo', 3, 'bar');\nmemoized('foo', 3, 'bar'); // Cache hit\n```\n\n### Configuration\n\nAll below options can be applied in any combination\n\n#### Arguments length\n\nBy default fixed number of arguments that function take is assumed (it's read from function's  `length` property) this can be overridden:\n\n```javascript\nmemoized = memoize(fn, { length: 2 });\n\nmemoized('foo');            // Assumed: 'foo', undefined\nmemoized('foo', undefined); // Cache hit\n\nmemoized('foo', 3, {}); // Third argument is ignored (but passed to underlying function)\nmemoized('foo', 3, 13); // Cache hit\n```\n\nDynamic _length_ behavior can be forced by setting _length_ to `false`, that means memoize will work with any number of arguments.\n\n```javascript\nmemoized = memoize(fn, { length: false });\n\nmemoized('foo');\nmemoized('foo'); // Cache hit\nmemoized('foo', undefined);\nmemoized('foo', undefined); // Cache hit\n\nmemoized('foo', 3, {});\nmemoized('foo', 3, 13);\nmemoized('foo', 3, 13); // Cache hit\n```\n\n#### Primitive mode\n\nIf we work with large result sets, or memoize hot functions, default mode may not perform as fast as we expect. In that case it's good to run memoization in _primitive_ mode. To provide fast access, results are saved in hash instead of an array. Generated hash ids are result of arguments to string conversion. __Mind that this mode will work correctly only if stringified arguments produce unique strings.__\n\n```javascript\nmemoized = memoize(fn, { primitive: true });\n\nmemoized('/path/one');\nmemoized('/path/one'); // Cache hit\n```\n\n#### Cache id resolution (normalization)\n\nBy default cache id for given call is resolved either by:\n- Direct Comparison of values passed in arguments as they are. In such case two different objects, even if their characteristics is exactly same (e.g. `var a = { foo: 'bar' }, b = { foo: 'bar' }`) will be treated as two different values.\n- Comparison of stringified values of given arguments (`primitive`  mode), which serves well, when arguments are expected to be primitive values, or objects that stringify naturally do unique values (e.g. arrays)\n\nStill above two methods do not serve all cases, e.g. if we want to memoize function where arguments are hash objects which we do not want to compare by instance but by its content.\n\n##### Writing custom cache id normalizers\n\nThere's a `normalizer` option through which we can pass custom cache id normalization function  \ne.g. if we want to memoize a function where argument is a hash object which we do not want to compare by instance but by its content, then we can achieve it as following:\n\n```javascript\nvar mfn = memoize(function (hash) {\n\t// body of memoized function\n}, { normalizer: function (args) {\n\t// args is arguments object as accessible in memoized function\n\treturn JSON.stringify(args[0]);\n} });\n\nmfn({ foo: 'bar' });\nmfn({ foo: 'bar' }); // Cache hit\n```\n\n#### Argument resolvers\n\nWhen we're expecting arguments of certain type it's good to coerce them before doing memoization. We can do that by passing additional resolvers array:\n\n```javascript\nmemoized = memoize(fn, { length: 2, resolvers: [String, Boolean] });\n\nmemoized(12, [1,2,3].length);\nmemoized(\"12\", true); // Cache hit\nmemoized({ toString: function () { return \"12\"; } }, {}); // Cache hit\n```\n\n__Note. If your arguments are collections (arrays or hashes) that you want to memoize by content (not by self objects), you need to cast them to strings__, for it's best to just use [primitive mode](#primitive-mode). Arrays have standard string representation and work with primitive mode out of a box, for hashes you need to define `toString` method, that will produce unique string descriptions, or rely on `JSON.stringify`.\n\nSimilarly __if you want to memoize functions by their code representation not by their objects, you should use primitive mode__.\n\n#### Memoizing asynchronous functions\n\n##### Promise returning functions\n\nWith _promise_ option we indicate that we memoize a function that returns promise.\n\nThe difference from natural behavior is that in case when promise was rejected with exception,\nthe result is immediately removed from memoize cache, and not kept as further reusable result.\n\n```javascript\nvar afn = function (a, b) {\n\treturn new Promise(function (res) { res(a + b); });\n};\nmemoized = memoize(afn, { promise: true });\n\nmemoized(3, 7);\nmemoized(3, 7); // Cache hit\n```\n\n###### Important notice on internal promises handling\n\nDefault handling stands purely on _then_ which has side-effect of muting eventual unhandled rejection notifications.\nAlternatively we can other (explained below), by stating with `promise` option desired mode:\n\n```javascript\nmemoized = memoize(afn, { promise: 'done:finally' });\n```\n\n Supported modes\n\n- `then` _(default)_. Values are resolved purely by passing callbacks to `promise.then`. __Side effect is that eventual unhandled rejection on given promise\ncome with no logged warning!__, and that to avoid implied error swallowing both states are resolved tick after callbacks were invoked\n\n- `done` Values are resolved purely by passing callback to `done` method. __Side effect is that eventual unhandled rejection on given promise come with now logged warning!__.\n\n- `done:finally` The only method that may work with no side-effects assuming that promise implementaion does not throw unconditionally\nif no _onFailure_ callback was passed to `done`, and promise error was handled by other consumer (this is not commonly implemented _done_ behavior). Otherwise side-effect is that exception is thrown on promise rejection (highly not recommended)\n\n\n##### Node.js callback style functions\n\nWith _async_ option we indicate that we memoize asynchronous (Node.js style) function\nOperations that result with an error are not cached.\n\n```javascript\nafn = function (a, b, cb) {\n  setTimeout(function () {\n    cb(null, a + b);\n  }, 200);\n};\nmemoized = memoize(afn, { async: true });\n\nmemoized(3, 7, function (err, res) {\n  memoized(3, 7, function (err, res) {\n    // Cache hit\n  });\n});\n\nmemoized(3, 7, function (err, res) {\n  // Cache hit\n});\n```\n\n#### Memoizing methods\n\nWhen we are defining a prototype, we may want to define a method that will memoize it's results in relation to each instance. A basic way to obtain that would be:\n\n```javascript\nvar Foo = function () {\n  this.bar = memoize(this.bar.bind(this), { someOption: true });\n  // ... constructor logic\n};\nFoo.prototype.bar = function () {\n  // ... method logic\n};\n```\n\nThere's a lazy methods descriptor generator provided:\n\n```javascript\nvar d = require('d');\nvar memoizeMethods = require('memoizee/methods');\n\nvar Foo = function () {\n  // ... constructor logic\n};\nObject.defineProperties(Foo.prototype, memoizeMethods({\n  bar: d(function () {\n    // ... method logic\n  }, { someOption: true })\n}));\n```\n\n#### WeakMap based configurations\n\nIn this case memoization cache is not bound to memoized function (which we may want to keep forever), but to objects for which given results were generated.\n\nThis mode works only for functions of which first argument is expected to be an object.  \nIt can be combined with other options mentioned across documentation. However due to WeakMap specificity global clear is not possible.\n\n```javascript\nvar memoize = require('memoizee/weak');\n\nvar memoized = memoize(function (obj) { return Object.keys(obj); });\n\nvar obj = { foo: true, bar: false };\nmemoized(obj);\nmemoized(obj); // Cache hit\n```\n\n#### Cache handling\n\n##### Manual clean up:\n\nDelete data for particular call.\n\n```javascript\nmemoized.delete('foo', true);\n```\n\nArguments passed to `delete` are treated with same rules as input arguments passed to function\n\nClear all cached data:\n\n```javascript\nmemoized.clear();\n```\n\n##### Expire cache after given period of time\n\nWith _maxAge_ option we can ensure that cache for given call is cleared after predefined period of time (in milliseconds)\n\n```javascript\nmemoized = memoize(fn, { maxAge: 1000 }); // 1 second\n\nmemoized('foo', 3);\nmemoized('foo', 3); // Cache hit\nsetTimeout(function () {\n  memoized('foo', 3); // No longer in cache, re-executed\n  memoized('foo', 3); // Cache hit\n}, 2000);\n```\n\nAdditionally we may ask to _pre-fetch_ in a background a value that is about to expire. _Pre-fetch_ is invoked only if value is accessed close to its expiry date. By default it needs to be within at least 33% of _maxAge_ timespan before expire:\n\n```javascript\nmemoized = memoize(fn, { maxAge: 1000, preFetch: true }); // Defaults to 0.33\n\nmemoized('foo', 3);\nmemoized('foo', 3); // Cache hit\n\nsetTimeout(function () {\n  memoized('foo', 3); // Cache hit\n}, 500);\n\nsetTimeout(function () {\n  memoized('foo', 3); // Cache hit, silently pre-fetched in next tick\n}, 800);\n\nsetTimeout(function () {\n  memoized('foo', 3); // Cache hit\n}, 1300);\n```\n\n_Pre-fetch_ timespan can be customized:\n\n```javascript\nmemoized = memoize(fn, { maxAge: 1000, preFetch: 0.6 });\n\nmemoized('foo', 3);\nmemoized('foo', 3); // Cache hit\n\nsetTimeout(function () {\n  memoized('foo', 3); // Cache hit, silently pre-fetched in next tick\n}, 500);\n\nsetTimeout(function () {\n  memoized('foo', 3); // Cache hit\n}, 1300);\n```\n\n_Thanks [@puzrin](https://github.com/puzrin) for helpful suggestions concerning this functionality_\n\n##### Reference counter\n\nWe can track number of references returned from cache, and manually delete them. When the last reference is cleared, the cache is purged automatically:\n\n```javascript\nmemoized = memoize(fn, { refCounter: true });\n\nmemoized('foo', 3);           // refs: 1\nmemoized('foo', 3);           // Cache hit, refs: 2\nmemoized('foo', 3);           // Cache hit, refs: 3\nmemoized.deleteRef('foo', 3); // refs: 2\nmemoized.deleteRef('foo', 3); // refs: 1\nmemoized.deleteRef('foo', 3); // refs: 0, Cache purged for 'foo', 3\nmemoized('foo', 3);           // Re-executed, refs: 1\n```\n\n##### Limiting cache size\n\nWith _max_ option you can limit cache size, it's backed with [LRU algorithm](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used), provided by low-level [lru-queue](https://github.com/medikoo/lru-queue) utility.\n\nThe _size_ relates purely to count of results we want to keep in cache, it doesn't relate to memory cost associated with cache value (but such feature is likely to be introduced with next version of memoizee).\n\n\n```javascript\nmemoized = memoize(fn, { max: 2 });\n\nmemoized('foo', 3);\nmemoized('bar', 7);\nmemoized('foo', 3);    // Cache hit\nmemoized('bar', 7);    // Cache hit\nmemoized('lorem', 11); // Cache cleared for 'foo', 3\nmemoized('bar', 7);    // Cache hit\nmemoized('foo', 3);    // Re-executed, Cache cleared for 'lorem', 11\nmemoized('lorem', 11); // Re-executed, Cache cleared for 'bar', 7\nmemoized('foo', 3);    // Cache hit\nmemoized('bar', 7);    // Re-executed, Cache cleared for 'lorem', 11\n```\n\n##### Registering dispose callback\n\nYou can register a callback to be called on each value removed from the cache:\n\n```javascript\nmemoized = memoize(fn, { dispose: function (value) { /*…*/ } });\n\nvar foo3 = memoized('foo', 3);\nvar bar7 = memoized('bar', 7);\nmemoized.clear('foo', 3); // Dispose called with foo3 value\nmemoized.clear('bar', 7); // Dispose called with bar7 value\n```\n\n### Benchmarks\n\nSimple benchmark tests can be found in _benchmark_ folder. Currently it's just plain simple calculation of fibonacci sequences. To run it you need to install other test candidates:\n\n\t$ npm install underscore lodash lru-cache secondary-cache\n\nExample output taken under Node v0.10.35 on 2011 MBP Pro:\n\n```\nFibonacci 3000 x10:\n\n1:    15ms  Memoizee (primitive mode)\n2:    15ms  Underscore\n3:    18ms  lru-cache                 LRU (max: 1000)\n4:    21ms  secondary-cache           LRU (max: 1000)\n5:    37ms  Lo-dash\n6:    62ms  Memoizee (primitive mode) LRU (max: 1000)\n7:   163ms  Memoizee (object mode)    LRU (max: 1000)\n8:   195ms  Memoizee (object mode)\n```\n\n### Profiling & Statistics\n\nIf you want to make sure how much you benefit from memoization or just check if memoization works as expected, loading profile module will give access to all valuable information.\n\n__Module needs to be imported before any memoization (that we want to track) is configured. Mind also that running profile module affects performance, it's best not to use it in production environment__\n\n```javascript\nvar memProfile = require('memoizee/profile');\n...\n...\nmemoize(fn);\n...\nmemoize(fn, { profileName: 'Some Function' })\n...\nmemoize(fn, { profileName: 'Another Function' })\n```\n\nAccess statistics at any time:\n\n```javascript\nmemProfile.statistics;         // Statistics accessible for programmatic use\nconsole.log(memProfile.log()); // Output statistics data in readable form\n```\n\nExample console output:\n\n```\n------------------------------------------------------------\nMemoize statistics:\n\n Init  Cache  %Cache  Source location\n11604  35682   75.46  (all)\n 2112  19901   90.41  Some Function, at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:276:12\n 2108   9087   81.17  Another Function, at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:293:10\n 6687   2772   29.31  at /Users/medikoo/Projects/_packages/next/lib/fs/watch.js:125:9\n  697   3922   84.91  at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:277:15\n------------------------------------------------------------\n```\n\n* _Init_ – Initial hits\n* _Cache_ – Cache hits\n* _%Cache_ – What's the percentage of cache hits (of all function calls)\n* _Source location_ – Where in the source code given memoization was initialized\n\n### Tests [![Build Status](https://img.shields.io/circleci/project/github/medikoo/memoizee.svg)](https://circleci.com/gh/medikoo/memoizee)\n\n\t$ npm test\n\nProject cross-browser compatibility to be supported by:\n\n<a href=\"https://browserstack.com\"><img src=\"https://bstacksupport.zendesk.com/attachments/token/Pj5uf2x5GU9BvWErqAr51Jh2R/?name=browserstack-logo-600x315.png\" height=\"150\" /></a>\n\n### Contributors\n\n* [@puzrin](https://github.com/puzrin) (Vitaly Puzrin)\n  * Proposal and help with coining right _pre-fetch_ logic for [_maxAge_](https://github.com/medikoo/memoize#expire-cache-after-given-period-of-time) variant\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/medikoo/memoizee.git"
  },
  "scripts": {
    "lint": "eslint --ignore-path=.gitignore .",
    "lint-medikoo": "xlint --linter=node_modules/xlint-jslint-medikoo/index.js",
    "test": "tad"
  },
  "version": "0.4.11"
}
